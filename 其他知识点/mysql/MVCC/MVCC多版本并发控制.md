## 一、前提概要

## 事务

#### 概念

​			一个事情由n个单元组成，这n个单元在执行过程中，要么同时成功，要么同时失败，这就把n个单元放在了一个事务之中。举个简单的例子：在不考虑试题正确与否的前提下，一张试卷由多个题目构成，当你答完题交给老师的时候是将一整张试卷交给老师，而不是将每道题单独交给老师，在这里试卷就可以理解成一个事务。

#### 事务的特性：ACID

A：原子性（`Atomicity`），原子性是指事务是一个不可分割的工作单位，事务中的操作，要么都发生，要么都不发生。

**例**：假设你在购物车里添加了两件衣服：上衣和裤子，当你把两件衣服作为一个订单提交支付的时候，要么两件衣服一起支付成功，要么都失败，不可能存在上衣付完钱了，裤子还没付完的情况，反之亦然。

C：一致性（`Consistency`），在一个事务中，事务前后数据的完整性必须保持一致,期望结果和预期结果一致,列的定义和约束不变。

**例**：例如用户转账,A通过sql语句扣钱1000,那么最终结果A就是扣了1000,数据上不可能多扣,并且这个列的数据不会因为数据变化导致列的类型或者约束发生变化

I：隔离性（`Isolation`），存在于多个事务中，事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。

**例**：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

D：持久性（`Durability`），持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。

**例**：我们在操作数据库时，事务提交或者回滚都会直接改变数据库中的值。

#### 事务的操作

在使用事务之前，首先我们要开启事务，我们可以通过`start`或者`begin`命令开启事务；如果我们想提交事务可以手动执行`commit`命令，如果我们想回滚事务，可以执行`rollback`命令。

注：在`MySQL`中事务的提交是默认开启的，可以执行`show variables like 'autocommit'`命令查看，如果是`ON`则证明自动提交已经开启，如果为`OFF`则需要手动提交。

#### 隔离性引发的并发问题

1）脏读：B事务读取到了A事务尚未提交的数据；

2）不可重复读：B事务读到了A事务已经提交的数据，即B事务在A事务提交之前和提交之后读取到的数据`内容`不一致（AB事务操作的是同一条数据）；

3）幻读/虚读：B事务读到了A事务已经提交的数据，即A事务执行插入操作，B事务在A事务前后读到的数据`数量`不一致。

#### 事务的隔离级别

为了解决以上隔离性引发的并发问题，数据库提供了事物的隔离机制。

- read uncommitted（读未提交）: 一个事务还没提交时，它做的变更就能被别的事务看到，读取尚未提交的数据，哪个问题都不能解决；
- read committed（读已提交）：一个事务提交之后，它做的变更才会被其他事务看到，读取已经提交的数据，可以解决脏读 ---- `oracle`默认的；
- repeatable read（可重复读）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的，可以解决脏读和不可重复读 ---`mysql`默认的；
- serializable（串行化）：顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。可以解决脏读、不可重复读和虚读---相当于锁表。

虽然`serializable`级别可以解决所有的数据库并发问题，但是它会在读取的每一行数据上都加锁，这就可能导致大量的超时和锁竞争问题，从而导致效率下降。所以我们在实际应用中也很少使用`serializable`，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。

## LBCC&MVCC

`InnoDB`默认的事务隔离级别是`repeatable read`（后文中用简称RR），它为了解决该隔离级别下的幻读的并发问题，提出了`LBCC`和`MVCC`两种方案。其中`LBCC`解决的是当前读情况下的幻读，`MVCC`解决的是普通读（快照读）的幻读。

### LBCC

`LBCC`是`Lock-Based Concurrent Control`的简称，意思是基于锁的并发控制。在`InnoDB`中按锁的模式来分的话可以分为共享锁（S）、排它锁（X）和意向锁，其中意向锁又分为意向共享锁（IS）和意向排它锁（IX）；如果按照锁的算法来分的话又分为记录锁（`Record Locks`）、间隙锁（`Gap Locks`）和临键锁（`Next-key Locks`）。其中临键锁就可以用来解决RR下的幻读问题。那么什么是临键锁呢？继续往下看。

![img](mdpic/b92a25cf-b138-4390-8b87-f9c4020c4f83.jpg)

我们将数据库中存储的每一行数据称为记录。则上图中1、5、9、11分别代表id为当前数的记录。对于键值在条件范围内但不存在的记录，叫做间隙（GAP）。则上图中的（-∞，1）、（1，5）...（11，+∞）为数据库中存在的间隙。而（-∞，1]、（1，5]...（11，+∞）我们称之为临键，即左开右闭的集合。

#### 记录锁（Record Locks）

对表中的行记录加锁，叫做记录锁，简称行锁。可以使用`sql`语句`select ... for update`来开启锁，`select`语句必须为精准匹配（=），不能为范围匹配，且匹配列字段必须为唯一索引或者主键列。也可以通过对查询条件为主键索引或唯一索引的数据行进行`UPDATE`操作来添加记录锁。

> 记录锁存在于包括主键索引在内的唯一索引中，锁定单条索引记录。

#### 间隙锁（GAP Locks）

对上面说到的间隙加锁即为间隙锁。间隙锁是对范围加锁，但不包括已存在的索引项。可以使用`sql`语句`select ... for update`来开启锁，`select`语句为范围查询，匹配列字段为索引项，且没有数据返回；或者`select`语句为等值查询，匹配字段为唯一索引，也没有数据返回。

间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。以下是加锁之后，插入操作的例子：

```java
select * from user where id > 15 for update;
//插入失败，因为id20大于15，不难理解
insert into user values(20,'20');
//插入失败，原因是间隙锁锁的是记录间隙，而不是sql，上面的图中间隙锁的最后一个数据是11,也就是说`select`语句的锁范围实际上是（11，+∞），而13在这个区间中，所以也失败。
insert into user values(13,'13');
```

> `GAP Locks`只存在于RR隔离级别下，它锁住的是间隙内的数据。加完锁之后，间隙中无法插入其他记录，并且锁的是记录间隙，而非`sql`语句。间隙锁之间都不存在冲突关系。

**打开间隙锁设置：** 以通过命令`show variables like 'innodb_locks_unsafe_for_binlog';`来查看 `innodb_locks_unsafe_for_binlog` 是否禁用。`innodb_locks_unsafe_for_binlog`默认值为OFF，即启用间隙锁。因为此参数是只读模式，如果想要禁用间隙锁，需要修改 `my.cnf`（windows是`my.ini`） 重新启动才行。

```properties
#在 my.cnf 里面的[mysqld]添加
[mysqld]
innodb_locks_unsafe_for_binlog = 1
```

#### 临键锁（Next-Key Locks）

当我们对上面的记录和间隙共同加锁时，添加的便是临键锁（左开右闭的集合加锁）。为了防止幻读，临键锁阻止特定条件的新记录的插入，因为插入时要获取插入意向锁，与已持有的临键锁冲突。可以使用`sql`语句`select ... for update`来开启锁，`select`语句为范围查询，匹配列字段为索引项，且有数据返回；或者`select`语句为等值查询，匹配列字段为索引项，不管有没有数据返回。

> 插入意向锁并非意向锁，而是一种特殊的间隙锁。

#### 总结

- 如果查询没有命中索引，则退化为表锁;
- 如果等值查询唯一索引且命中唯一一条记录，则退化为行锁;
- 如果等值查询唯一索引且没有命中记录，则退化为临近结点的间隙锁;
- 如果等值查询非唯一索引且没有命中记录，退化为临近结点的间隙锁(包括结点也被锁定)；如果命中记录，则锁定所有命中行的临键锁，并同时锁定最大记录行下一个区间的间隙锁。
- 如果范围查询唯一索引或查询非唯一索引且命中记录，则锁定所有命中行的临键锁 ，并同时锁定最大记录行下一个区间的间隙锁。
- 如果范围查询索引且没有命中记录，退化为临近结点的间隙锁(包括结点也被锁定)。

#### 当前读

当前读（`Locking Read`）也称锁定读，读取当前数据的最新版本，而且读取到这个数据之后会对这个数据加锁，防止别的事务更改即通过`next-key`锁（行锁+gap锁）来解决当前读的问题。在进行写操作的时候就需要进行“当前读”，读取数据记录的最新版本，包含以下`SQL`类型：`select ... lock in share mode` 、`select ... for update`、`update` 、`delete` 、`insert`。



#### 什么是MVCC?

> `LBCC`是基于锁的并发控制，因为锁的粒度过大，会导致性能的下降，因此提出了比`LBCC`性能更优越的方法`MVCC`。`MVCC`是`Multi-Version Concurrent Control`的简称，意思是基于多版本的并发控制，通过版本号，避免同一数据在不同事务间的竞争，只存在于`InnoDB`引擎下。它主要是为了提高数据库的并发读写性能，不用加锁就能让多个事务并发读写。`MVCC`的实现依赖于：三个隐藏字段、`Undo log`和`Read View`，其核心思想就是：只能查找事务id小于等于当前事务ID的行；只能查找删除时间大于等于当前事务ID的行，或未删除的行。

MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读

#### 什么是当前读和快照读？

在学习MVCC多版本并发控制之前，我们必须先了解一下，什么是MySQL InnoDB下的当前读和快照读?

- 当前读
   像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。
- 快照读
   像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现

#### 当前读，快照读和MVCC的关系

- 准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念。仅仅是一个理想概念
- 而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现
- 要说的再细致一些，快照读本身也是一个抽象概念，再深入研究。MVCC模型在MySQL中的具体实现则是由 3个隐式字段，undo日志 ，Read View 等去完成的，具体可以看下面的MVCC实现原理

#### MVCC能解决什么问题，好处是？

###### 数据库并发场景有三种，分别为：

- 读-读：不存在任何问题，也不需要并发控制
- 读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读
- 写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失

###### MVCC带来的好处是？

多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题

- 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能
- 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题

###### 小结一下咯

总之，MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：

- MVCC + 悲观锁
   MVCC解决读写冲突，悲观锁解决写写冲突
- MVCC + 乐观锁
   MVCC解决读写冲突，乐观锁解决写写冲突
   这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题

## 二、MVCC的实现原理

MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的 3个隐式字段，undo日志 ，Read View 来实现的。所以我们先来看看这个三个point的概念

#### 隐式字段

- `MySQL`中会为每一行记录生成隐藏列，接下来就让我们了解一下这几个隐藏列吧。

  （1）DB_TRX_ID：事务ID，是根据事务产生时间顺序自动递增的，是独一无二的。如果某个事务执行过程中对该记录执行了增、删、改操作，那么`InnoDB`存储引擎就会记录下该条事务的id。
  
  （2）DB_ROLL_PTR：回滚指针，本质上就是一个指向记录对应的`undo log`的一个指针，大小为 7 个字节，`InnoDB` 便是通过这个指针找到之前版本的数据。该行记录上所有旧版本，在`undo log`中都通过链表的形式组织。
  
  （3）DB_ROW_ID：行标识（隐藏单调自增 `ID`），如果表没有主键，InnoDB 会自动生成一个隐藏主键，大小为 6 字节。如果数据表没有设置主键，会以它产生聚簇索引。
  
  （4）实际还有一个删除flag隐藏字段，既记录被更新或删除并不代表真的删除，而是删除flag变了。
  
- ![img](mdpic/3133209-b45e9ebf0a3d8b14.png)

如上图，DB_ROW_ID是数据库默认为该行记录生成的唯一隐式主键，DB_TRX_ID是当前操作该记录的事务ID,而DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本



#### undo日志

- 每当我们要对一条记录做改动时（这里的改动可以指INSERT、DELETE、UPDATE），都需要把回滚时所需的东西记录下来, 比如:
  
   - Insert undo log ：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。
   - Delete undo log：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。
   - Update undo log：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。
     `InnoDB`把这些为了回滚而记录的这些东西称之为`undo log`。这里需要注意的一点是，由于查询操作（`SELECT`）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的`undo log`。
   
   每次对记录进行改动都会记录一条undo日志，每条undo日志也都有一个`DB_ROLL_PTR`属性，可以将这些undo日志都连起来，串成一个链表，形成版本链。版本链的头节点就是当前记录最新的值。不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除

> purge
>
> - 从前面的分析可以看出，为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。
> - 为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。

对MVCC有帮助的实质是update undo log ，undo log实际上就是存在rollback segment中旧记录链，它的执行流程如下：

一、 比如一个有个事务插入persion表插入了一条新记录，记录如下，name为Jerry, age为24岁，隐式主键是1，事务ID和回滚指针，我们假设为NULL

![img](mdpic/3133209-e52ee5ae248c5a08.png)

二、 现在来了一个事务1对该记录的name做出了修改，改为Tom

- 在事务1修改该行(记录)数据时，数据库会先对该行加排他锁

- 然后把该行数据拷贝到undo log中，作为旧记录，既在undo log中有当前行的拷贝副本

- 拷贝完毕后，修改该行name为Tom，并且修改隐藏字段的事务ID为当前事务1的ID, 我们默认从1开始，之后递增，回滚指针指向拷贝到undo log的副本记录，既表示我的上一个版本就是它

- 事务提交后，释放锁

  ![img](mdpic/3133209-3b89396902dbf513.png)

三、 又来了个事务2修改person表的同一个记录，将age修改为30岁

- 在事务2修改该行数据时，数据库也先为该行加锁

- 然后把该行数据拷贝到undo log中，作为旧记录，发现该行记录已经有undo log了，那么最新的旧数据作为链表的表头，插在该行记录的undo log最前面

- 修改该行age为30岁，并且修改隐藏字段的事务ID为当前事务2的ID, 那就是2，回滚指针指向刚刚拷贝到undo log的副本记录

- 事务提交，释放锁

  ![img](mdpic/3133209-70cdae4621d5543e.png)

从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，既链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该undo log的节点可能是会purge线程清除掉，向图中的第一条insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里）

#### Read View(读视图)

在可重复读隔离级别下，我们可以把每一次普通的`select`查询（不加`for update`语句）当作一次快照读，而快照便是进行`select`的那一刻，生成的当前数据库系统中所有未提交的事务id数组（数组里最小的`id`为`min_id`）和已经创建的最大事务`id`（`max_id`）的集合，即我们所说的一致性视图`readview`。在进行快照读的过程中要根据一定的规则将版本链中每个版本的事务`id`与`readview`进行匹配查询我们需要的结果。

快照读是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。快照读的实现是基于多版本并发控制，即`MVCC`，可以认为`MVCC`是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。`MVCC`只在 `READ COMMITTED` 和 `REPEATABLE READ`两个隔离级别下工作，其他两个隔离级别不和`MVCC`不兼容。因为`READ UNCOMMITTED`总是读取最新的数据行，而不是符合当前事务版本的数据行，而`SERIALIZABLE` 则会对所有读取的行都加锁。事务的快照时间点（即下文中说到的`Read View`的生成时间）是以第一个`select`来确认的。所以即便事务先开始，但是`select`在后面的事务的`update`之类的语句后进行，那么它是可以获取前面的事务的对应的数据。

> RC和RR隔离级别下的快照读和当前读：RC隔离级别下，快照读和当前读结果一样，都是读取已提交的最新；RR隔离级别下，当前读结果是其他事务已经提交的最新结果，快照读是读当前事务之前读到的结果。RR下创建快照读的时机决定了读到的版本。

对于使用RC和RR隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的。核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的。为此，`InnoDB`提出了一个`Read View`的概念。

`Read View`就是事务进行快照读（普通`select`查询）操作的时候生产的一致性读视图，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，它由执行查询时所有未提交的事务id数组（数组里最小的id为`min_id`）和已经创建的最大事务id（`max_id`）组成，查询的数据结果需要跟`read view`做对比从而得到快照结果。

![快照规则](mdpic/106869a2-451b-468a-af74-2563176dd1ee.jpg)

**版本链比对规则：**

1. 如果落在绿色部分（trx_id<min_id），表示这个版本是已经提交的事务生成的，这个数据是可见的；
2. 如果落在红色部分（trx_id>max_id），表示这个版本是由将来启动的事务生成的，是肯定不可见的；
3. 如果落在黄色部分（min_id<=trx_id<=max_id），那就包含两种情况：
   a.若row的trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；如果是自己的事务，则是可见的；
   b.若row的trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。

那么这个判断条件是什么呢？

```c
/** Check whether the changes by id are visible.
	@param[in]	id	transaction id to check against the view
	@param[in]	name	table name
	@return whether the view sees the modifications of id. */
	bool changes_visible(
		trx_id_t		id, //当前事务id
		const table_name_t&	name) const
		MY_ATTRIBUTE((warn_unused_result))
	{
		ut_ad(id > 0);

		if (id < m_up_limit_id || id == m_creator_trx_id) {

			return(true);
		}

		check_trx_id_sanity(id, name);

		if (id >= m_low_limit_id) {

			return(false);

		} else if (m_ids.empty()) {

			return(true);
		}

		const ids_t::value_type*	p = m_ids.data();

		return(!std::binary_search(p, p + m_ids.size(), id));
	}

```



如上，它是一段MySQL判断可见性的一段源码，即changes_visible方法，该方法展示了我们拿DB_TRX_ID去跟Read View某些属性进行怎么样的比较

在展示之前，我先简化一下Read View，我们可以把Read View简单的理解成有三个全局属性

> m_ids(trx_list)
>  一个数值列表，用来维护Read View生成时刻系统正活跃的事务ID
>  up_limit_id
>  记录trx_list列表中事务ID最小的ID
>  low_limit_id
>  ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1

- 首先比较DB_TRX_ID < up_limit_id, 如果小于，则当前事务能看到DB_TRX_ID 所在的记录，如果大于等于进入下一个判断
- 接下来判断 DB_TRX_ID 大于等于 low_limit_id , 如果大于等于则代表DB_TRX_ID 所在的记录在Read View生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断
- 判断m_ids.empty()如果空则说明，你这个事务在Read View生成之前就已经Commit了，你修改的结果，我当前事务是能看见的

#### 整体流程

我们在了解了隐式字段，undo log， 以及Read View的概念之后，就可以来看看MVCC实现的整体流程是怎么样了

整体的流程是怎么样的呢？我们可以模拟一下

- 当事务2对某行数据执行了快照读，数据库为该行数据生成一个Read View读视图，假设当前事务ID为2，此时还有事务1和事务3在活跃中，事务4在事务2快照读前一刻提交更新了，所以Read View记录了系统当前活跃事务1，3的ID，维护在一个列表上，假设我们称为trx_list

  ![img](mdpic/3133209-cbf70159f8628101.png)

- Read View不仅仅会通过一个列表trx_list来维护事务2执行快照读那刻系统正活跃的事务ID，还会有两个属性up_limit_id（记录trx_list列表中事务ID最小的ID），low_limit_id(记录trx_list列表中事务ID最大的ID，也有人说快照读那刻系统尚未分配的下一个事务ID也就是目前已出现过的事务ID的最大值+1，我更倾向于后者；所以在这里例子中up_limit_id就是1，low_limit_id就是4 + 1 = 5，trx_list集合的值是1,3，Read View如下图

  ![img](mdpic/3133209-1d56c923cf5c6cad.png)

- 我们的例子中，只有事务4修改过该行记录，并在事务2执行快照读前，就提交了事务，所以当前该行当前数据的undo log如下图所示；我们的事务2在快照读该行记录的时候，就会拿该行记录的DB_TRX_ID去跟up_limit_id,low_limit_id和活跃事务ID列表(trx_list)进行比较，判断当前事务2能看到该记录的版本是哪个。

  ![img](mdpic/3133209-615fefab74cacee0.png)

- 所以先拿该记录DB_TRX_ID字段记录的事务ID 4去跟Read View的的up_limit_id比较，看4是否小于up_limit_id(1)，所以不符合条件，继续判断 4 是否大于等于 low_limit_id(5)，也不符合条件，最后判断4是否处于trx_list中的活跃事务, 最后发现事务ID为4的事务不在当前活跃事务列表中, 符合可见性条件，所以事务4修改后提交的最新结果对事务2快照读时是可见的，所以事务2能读到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本

  ![img](mdpic/3133209-be5885051c52fb6a.png)

- 也正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同

#### 例子 

首先我们要准备两张表，一张`test`和一张`account`表，然后我们以`account`的`undo log`来画版本链，准备数据和原始记录图如下

```java
//test表中数据
id=1,c1='11';
id=5,c1='22';
//account表数据
id=1，name=‘lilei’；
```

![img](mdpic/a0a6337f-a945-4074-9693-f92758a2447f.jpg)
如下图，我们将按照里面的顺序执行`sql`
![RR模式下多个事务执行](mdpic/eadb43c3-0bf0-4d1c-9449-0fb5bc1c4fcd.jpg)
当我们执行到第7行的`select`的语句时，会生成`readview[100,200],300`,版本链如图所示：
![img](mdpic/ab1f8116-be00-42c0-ad47-ee9f3eb1bf7a.jpg)
此时我们查询到的数据为`lilei300`。我们首先要拿最新版本的数据`trx_id=300`来`readview`中匹配，落在黄色区间内，一看该数据已经提交了，所以是可见的。继续往下执行，当执行到第10行的`select`语句时，因为`trx_id=100`并未提交，所以版本链依然为`readview[100,200],300`，版本链如图所示：
![img](mdpic/70b77ff2-2625-4035-a3a4-52116e490b04.jpg)
此时我们查询到的数据为`lilei300`。我们按上边操作，从最新版本依次往下匹配，我们首先要拿最新版本的数据`trx_id=100`来`readview`中匹配，落在黄色区间内，一看该数据在未提交的数组中，且不是自己的事务，所以是不可见的；然后我们选择前一个版本的数据，结果同上；继续向上找，当找到`trx_id=300`的数据时，会落在黄色区间，且是提交的，所以数据可见。继续往下执行，当执行到第13行的`select`语句时，此时尽管`trx_id=100`已经提交了，因为是`InnoDB`的RR模式，所以`readview`不会更改，仍为`readview[100,200],300`,版本链如图所示：
![img](mdpic/e2a318f8-7ced-4ce3-9d79-7a441a3b18d1.jpg)
此时我们查询到的数据为`lilei300`。原因同上边的步骤，不再赘述。

> 当执行`update`语句时，都是先读后写的，而这个读，是当前读，只能读当前的值，跟`readview`查找时的快照读区分开。

刚才演示的是`InnoDB`下的RR模式，接下来我们简单说一下RC模式，上文中提到的RC模式的数据读都是读最新的即当前读，所以readview是实时生成的，执行语句如图所示：
![RC模式下多事务执行](mdpic/383a87fe-d5a8-47b7-bc0e-b4b5dd53ba22.jpg)
当我们执行到第13行的`select`的语句时，会生成`readview[200],300`，版本链还和之前一样，此时我们查询到的数据为`lilei2`。原因和上边讲的RR模式下的比对规则相同。

此处我们演示的是`update`的情况，对于删除的情况可以认为是`update`的特殊情况，会将版本链上最新的数据复制一份，然后将`trx_id`改成删除操作的`trx_id`，同时在该条记录的头信息（`record header`）里的（`deleted_flag`）标记位上写上`true`，来表示当前记录已经被删除，在查询时按照上边的规则查到对应的记录，如果`delete_flag`标记位为`true`，意味着记录已被删除，则不返回数据。

大家应该还关心一个问题，即`undo log`什么时候删除呢？系统会判断，没有比这个`undo log`更早的`read view`的时候，`undo log`会被删除。所以这里也就是为什么我们建议你尽量不要使用长事务的原因。长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。



## 三、MVCC相关问题

#### RR是如何在RC级的基础上解决不可重复读的？

当前读和快照读在RR级别下的区别：
 表1:

![img](mdpic/3133209-1d04f4bede14f4b5.png)

表2:

![img](mdpic/3133209-ba10316e166babf6.png)

而在表2这里的顺序中，事务B在事务A提交后的快照读和当前读都是实时的新数据400，这是为什么呢？

- 这里与上表的唯一区别仅仅是表1的事务B在事务A修改金额前快照读过一次金额数据，而表2的事务B在事务A修改金额前没有进行过快照读。

所以我们知道事务中快照读的结果是非常依赖该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力

我们这里测试的是更新，同时删除和更新也是一样的，如果事务B的快照读是在事务A操作之后进行的，事务B的快照读也是能读取到最新的数据的

#### RC,RR级别下的InnoDB快照读有什么不同？

正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同

- 在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见；
- 即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见
- 而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因

总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。

